# 100 days of codeUp

### Day 1/100
Today I started a course about Go, I took some time to get familiar with the structure of the language, basic syntax, operators and variables.

### Day 2/100
Today I learned about numeric systems, constants and the runtime package in Go, I also did the local environment setup for developing in VS code and started checking possible projects to develop in order to practice Go.

### Day 3/100
Today I kept my studies about golang, I learned how to create and manipulate arrays, slices and maps, tested some variations of for loop and learned how to use structs. I also solved two leetcode problems using Go.

### Day 4/100
Today I learned how to create functions in Go, how to return multiple values, how everything is passed by value and never by reference.

### Day 5/100
Today I studied few more things about Go, I learned about 'defer', interfaces, how to use polymorphism, and I tested on my local environment some things related to pointers and memory address.

### Day 6/100
Today I learned about recursive functions, callback and pointers in Go, I also started developing a little practical project to enhance my skills in the language.

### Day 7/100
Today I learned about the concepts of working with JSON in Go - how to encode and decode datatypes, I searched about go modules and tested the package github.com/spf13/cobra for working with interactive CLI applications.

### Day 8/100
Today I learned about hashing using the package bcrypt and I started learning the theory for concurrency and paralelism with goRoutines.

### Day 9/100
I keep learning Golang, today I saw the usage of mutex for parallel jobs, race conditions, how Go manage the threads according to the number of cpus available in the computer. I learned also how to do cross-compilation generating executable for windows from a mac for example.

### Day 10/100
I keep learning Golang, today I watched some content about channels and I need to create some tests locally for better understanding.
I also started a practical project for fetching crypto prices using Go.

### Day 11/100
Today I learned a bit more about channels (range, close, select). And I kept working on my practical project for fetching crypto prices, I implemented an http request to get data from api.coingecko.com and I created a interactive CLI where the user can choose which coins to fetch the price.

### Day 12/100
Today I kept studying Golang - I saw some theory about pointers, stack and heap. And I made some more changes in the coin-fetcher project, adding a table price in the console for a more friendly view.

### Day 13/100
Today I implemented the SaveToFile function in my coin-fetcher project in golang, with options to save the retrieved data in a csv or json file. I also learned a bit about the context package in Go which is used for cancellations or timeouts.

### Day 14/100
Today I learned about error handling in Go, the different usages of the log package, and how to use panic and recover keywords for managing the application flow.

### Day 15/100
Today I learned about error type in Go, how to construct an error in any part of my application, and the convention for using error type as return of functions. I also learned how to create documentation of my code using godoc.

### Day 16/100
I keep studying golang, today I learned how to create unit tests for my projects using the standard library, and learned about the design patterns fan-in, fan-out and pool of workers.

### Day 17/100
Today I practiced a bit more of coding in Go, I reviewed some content channels (receiving, sending) and synchronization of channels. And I uploaded a new leetcode solution solving the validParentheses problem using stack.

### Day 18/100
Today I had a look on common interview questions in Golang and based on that I started going deeper in some topics, the first was how Garbage collector works in go, I learned that it works based on mark-sweep strategy, it runs concurrently with goroutines and it requires just a minimal time to execute. The second topic was about slices and arrays, how slices always have an underlying array and how a new array is created when appending to a slice which has reached its maximum capacity.

### Day 19/100
Today I tested some different ways to create slices in Go using cap and len. I also created an interface and concrete implementations of that interface in order to test polymorphism.

### Day 20/100
I keep studying golang, today I created some examples of functions receiving parameters like pointers, maps, slices, I took some time to understand what happens when we modify the slice or map inside the function. I also learned and tested the sync.RWMutex, which it's useful when working with concurrent programs.
